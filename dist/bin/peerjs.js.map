{"mappings":"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","sources":["package.json","src/config/index.ts","src/models/messageQueue.ts","src/models/realm.ts","src/services/checkBrokenConnections/index.ts","src/enums.ts","src/services/messagesExpire/index.ts","src/models/client.ts","src/services/webSocketServer/index.ts","src/messageHandler/handlers/heartbeat/index.ts","src/messageHandler/handlers/transmission/index.ts","src/messageHandler/handlersRegistry.ts","src/messageHandler/index.ts","app.json","src/api/v1/public/index.ts","src/api/index.ts","src/instance.ts","bin/peerjs.ts","src/index.ts"],"sourcesContent":["{\r\n\t\"name\": \"peer\",\r\n\t\"version\": \"1.0.0\",\r\n\t\"keywords\": [\r\n\t\t\"peerjs\",\r\n\t\t\"webrtc\",\r\n\t\t\"p2p\",\r\n\t\t\"rtc\"\r\n\t],\r\n\t\"description\": \"PeerJS server component\",\r\n\t\"homepage\": \"https://peerjs.com\",\r\n\t\"bugs\": {\r\n\t\t\"url\": \"https://github.com/peers/peerjs-server/issues\"\r\n\t},\r\n\t\"repository\": {\r\n\t\t\"type\": \"git\",\r\n\t\t\"url\": \"https://github.com/peers/peerjs-server\"\r\n\t},\r\n\t\"license\": \"MIT\",\r\n\t\"contributors\": [],\r\n\t\"type\": \"module\",\r\n\t\"exports\": {\r\n\t\t\".\": {\r\n\t\t\t\"import\": {\r\n\t\t\t\t\"types\": \"./dist/peer.d.ts\",\r\n\t\t\t\t\"default\": \"./dist/module.mjs\"\r\n\t\t\t},\r\n\t\t\t\"require\": {\r\n\t\t\t\t\"types\": \"./dist/peer.d.ts\",\r\n\t\t\t\t\"default\": \"./dist/index.cjs\"\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t\"main\": \"dist/index.cjs\",\r\n\t\"module\": \"dist/module.mjs\",\r\n\t\"source\": \"src/index.ts\",\r\n\t\"binary\": \"dist/bin/peerjs.js\",\r\n\t\"types\": \"dist/peer.d.ts\",\r\n\t\"bin\": {\r\n\t\t\"peerjs\": \"dist/bin/peerjs.js\"\r\n\t},\r\n\t\"funding\": {\r\n\t\t\"type\": \"opencollective\",\r\n\t\t\"url\": \"https://opencollective.com/peer\"\r\n\t},\r\n\t\"collective\": {\r\n\t\t\"type\": \"opencollective\",\r\n\t\t\"url\": \"https://opencollective.com/peer\"\r\n\t},\r\n\t\"files\": [\r\n\t\t\"dist/\"\r\n\t],\r\n\t\"engines\": {\r\n\t\t\"node\": \">=14\"\r\n\t},\r\n\t\"targets\": {\r\n\t\t\"binary\": {\r\n\t\t\t\"source\": \"bin/peerjs.ts\"\r\n\t\t},\r\n\t\t\"main\": {},\r\n\t\t\"module\": {}\r\n\t},\r\n\t\"scripts\": {\r\n\t\t\"format\": \"prettier --write .\",\r\n\t\t\"build\": \"parcel build\",\r\n\t\t\"lint\": \"eslint --ext .js,.ts . && npm run check\",\r\n\t\t\"check\": \"tsc --noEmit\",\r\n\t\t\"test\": \"\",\r\n\t\t\"coverage\": \"jest --coverage\",\r\n\t\t\"start\": \"node dist/bin/peerjs.js --port ${PORT:=9000}\",\r\n\t\t\"dev\": \"nodemon --watch src -e ts --exec 'npm run build && npm run start'\",\r\n\t\t\"semantic-release\": \"semantic-release\"\r\n\t},\r\n\t\"dependencies\": {\r\n\t\t\"@types/express\": \"^4.17.3\",\r\n\t\t\"@types/ws\": \"^7.2.3 || ^8.0.0\",\r\n\t\t\"cors\": \"^2.8.5\",\r\n\t\t\"express\": \"^4.17.1\",\r\n\t\t\"node-fetch\": \"^3.3.0\",\r\n\t\t\"ws\": \"^7.2.3 || ^8.0.0\",\r\n\t\t\"yargs\": \"^17.6.2\"\r\n\t},\r\n\t\"devDependencies\": {\r\n\t\t\"@codedependant/semantic-release-docker\": \"^4.3.0\",\r\n\t\t\"@parcel/packager-ts\": \"^2.8.2\",\r\n\t\t\"@parcel/transformer-typescript-types\": \"^2.8.2\",\r\n\t\t\"@semantic-release/changelog\": \"^6.0.1\",\r\n\t\t\"@semantic-release/git\": \"^10.0.1\",\r\n\t\t\"@swc/core\": \"^1.3.35\",\r\n\t\t\"@swc/jest\": \"^0.2.24\",\r\n\t\t\"@tsconfig/node16-strictest-esm\": \"^1.0.3\",\r\n\t\t\"@types/cors\": \"^2.8.6\",\r\n\t\t\"@types/jest\": \"^29.4.0\",\r\n\t\t\"@types/node\": \"^14.18.33\",\r\n\t\t\"@types/yargs\": \"^17.0.19\",\r\n\t\t\"@typescript-eslint/eslint-plugin\": \"^5.0.0\",\r\n\t\t\"@typescript-eslint/parser\": \"^5.0.0\",\r\n\t\t\"eslint\": \"^8.0.0\",\r\n\t\t\"jest\": \"^29.4.2\",\r\n\t\t\"mock-socket\": \"^9.1.5\",\r\n\t\t\"parcel\": \"^2.8.2\",\r\n\t\t\"prettier\": \"^2.8.4\",\r\n\t\t\"semantic-release\": \"^20.0.0\",\r\n\t\t\"typescript\": \"^4.1.2\"\r\n\t}\r\n}\r\n","import type { WebSocketServer, ServerOptions } from \"ws\";\r\nimport type { CorsOptions } from \"cors\";\r\n\r\nexport interface IConfig {\r\n\treadonly host: string;\r\n\treadonly port: number;\r\n\treadonly expire_timeout: number;\r\n\treadonly alive_timeout: number;\r\n\treadonly key: string;\r\n\treadonly path: string;\r\n\treadonly concurrent_limit: number;\r\n\treadonly allow_discovery: boolean;\r\n\treadonly proxied: boolean | string;\r\n\treadonly cleanup_out_msgs: number;\r\n\treadonly ssl?: {\r\n\t\tkey: string;\r\n\t\tcert: string;\r\n\t};\r\n\treadonly generateClientId?: () => string;\r\n\treadonly createWebSocketServer?: (options: ServerOptions) => WebSocketServer;\r\n\treadonly corsOptions: CorsOptions;\r\n}\r\n\r\nconst defaultConfig: IConfig = {\r\n\thost: \"::\",\r\n\tport: 9000,\r\n\texpire_timeout: 5000,\r\n\talive_timeout: 60000,\r\n\tkey: \"peerjs\",\r\n\tpath: \"/\",\r\n\tconcurrent_limit: 5000,\r\n\tallow_discovery: false,\r\n\tproxied: false,\r\n\tcleanup_out_msgs: 1000,\r\n\tcorsOptions: { origin: true },\r\n};\r\n\r\nexport default defaultConfig;\r\n","import type { IMessage } from \"./message\";\r\n\r\nexport interface IMessageQueue {\r\n\tgetLastReadAt(): number;\r\n\r\n\taddMessage(message: IMessage): void;\r\n\r\n\treadMessage(): IMessage | undefined;\r\n\r\n\tgetMessages(): IMessage[];\r\n}\r\n\r\nexport class MessageQueue implements IMessageQueue {\r\n\tprivate lastReadAt: number = new Date().getTime();\r\n\tprivate readonly messages: IMessage[] = [];\r\n\r\n\tpublic getLastReadAt(): number {\r\n\t\treturn this.lastReadAt;\r\n\t}\r\n\r\n\tpublic addMessage(message: IMessage): void {\r\n\t\tthis.messages.push(message);\r\n\t}\r\n\r\n\tpublic readMessage(): IMessage | undefined {\r\n\t\tif (this.messages.length > 0) {\r\n\t\t\tthis.lastReadAt = new Date().getTime();\r\n\t\t\treturn this.messages.shift();\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tpublic getMessages(): IMessage[] {\r\n\t\treturn this.messages;\r\n\t}\r\n}\r\n","import type { IMessageQueue } from \"./messageQueue\";\r\nimport { MessageQueue } from \"./messageQueue\";\r\nimport { randomUUID } from \"node:crypto\";\r\nimport type { IClient } from \"./client\";\r\nimport type { IMessage } from \"./message\";\r\n\r\nexport interface IRealm {\r\n\tgetClientsIds(): string[];\r\n\r\n\tgetClientById(clientId: string): IClient | undefined;\r\n\r\n\tgetClientsIdsWithQueue(): string[];\r\n\r\n\tsetClient(client: IClient, id: string): void;\r\n\r\n\tremoveClientById(id: string): boolean;\r\n\r\n\tgetMessageQueueById(id: string): IMessageQueue | undefined;\r\n\r\n\taddMessageToQueue(id: string, message: IMessage): void;\r\n\r\n\tclearMessageQueue(id: string): void;\r\n\r\n\tgenerateClientId(generateClientId?: () => string): string;\r\n}\r\n\r\nexport class Realm implements IRealm {\r\n\tprivate readonly clients: Map<string, IClient> = new Map();\r\n\tprivate readonly messageQueues: Map<string, IMessageQueue> = new Map();\r\n\r\n\tpublic getClientsIds(): string[] {\r\n\t\treturn [...this.clients.keys()];\r\n\t}\r\n\r\n\tpublic getClientById(clientId: string): IClient | undefined {\r\n\t\treturn this.clients.get(clientId);\r\n\t}\r\n\r\n\tpublic getClientsIdsWithQueue(): string[] {\r\n\t\treturn [...this.messageQueues.keys()];\r\n\t}\r\n\r\n\tpublic setClient(client: IClient, id: string): void {\r\n\t\tthis.clients.set(id, client);\r\n\t}\r\n\r\n\tpublic removeClientById(id: string): boolean {\r\n\t\tconst client = this.getClientById(id);\r\n\r\n\t\tif (!client) return false;\r\n\r\n\t\tthis.clients.delete(id);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic getMessageQueueById(id: string): IMessageQueue | undefined {\r\n\t\treturn this.messageQueues.get(id);\r\n\t}\r\n\r\n\tpublic addMessageToQueue(id: string, message: IMessage): void {\r\n\t\tif (!this.getMessageQueueById(id)) {\r\n\t\t\tthis.messageQueues.set(id, new MessageQueue());\r\n\t\t}\r\n\r\n\t\tthis.getMessageQueueById(id)?.addMessage(message);\r\n\t}\r\n\r\n\tpublic clearMessageQueue(id: string): void {\r\n\t\tthis.messageQueues.delete(id);\r\n\t}\r\n\r\n\tpublic generateClientId(generateClientId?: () => string): string {\r\n\t\tconst generateId = generateClientId ? generateClientId : randomUUID;\r\n\r\n\t\tlet clientId = generateId();\r\n\r\n\t\twhile (this.getClientById(clientId)) {\r\n\t\t\tclientId = generateId();\r\n\t\t}\r\n\r\n\t\treturn clientId;\r\n\t}\r\n}\r\n","import type { IConfig } from \"../../config\";\r\nimport type { IClient } from \"../../models/client\";\r\nimport type { IRealm } from \"../../models/realm\";\r\n\r\nconst DEFAULT_CHECK_INTERVAL = 300;\r\n\r\ntype CustomConfig = Pick<IConfig, \"alive_timeout\">;\r\n\r\nexport class CheckBrokenConnections {\r\n\tpublic readonly checkInterval: number;\r\n\tprivate timeoutId: NodeJS.Timeout | null = null;\r\n\tprivate readonly realm: IRealm;\r\n\tprivate readonly config: CustomConfig;\r\n\tprivate readonly onClose?: (client: IClient) => void;\r\n\r\n\tconstructor({\r\n\t\trealm,\r\n\t\tconfig,\r\n\t\tcheckInterval = DEFAULT_CHECK_INTERVAL,\r\n\t\tonClose,\r\n\t}: {\r\n\t\trealm: IRealm;\r\n\t\tconfig: CustomConfig;\r\n\t\tcheckInterval?: number;\r\n\t\tonClose?: (client: IClient) => void;\r\n\t}) {\r\n\t\tthis.realm = realm;\r\n\t\tthis.config = config;\r\n\t\tthis.onClose = onClose;\r\n\t\tthis.checkInterval = checkInterval;\r\n\t}\r\n\r\n\tpublic start(): void {\r\n\t\tif (this.timeoutId) {\r\n\t\t\tclearTimeout(this.timeoutId);\r\n\t\t}\r\n\r\n\t\tthis.timeoutId = setTimeout(() => {\r\n\t\t\tthis.checkConnections();\r\n\r\n\t\t\tthis.timeoutId = null;\r\n\r\n\t\t\tthis.start();\r\n\t\t}, this.checkInterval);\r\n\t}\r\n\r\n\tpublic stop(): void {\r\n\t\tif (this.timeoutId) {\r\n\t\t\tclearTimeout(this.timeoutId);\r\n\t\t\tthis.timeoutId = null;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate checkConnections(): void {\r\n\t\tconst clientsIds = this.realm.getClientsIds();\r\n\r\n\t\tconst now = new Date().getTime();\r\n\t\tconst { alive_timeout: aliveTimeout } = this.config;\r\n\r\n\t\tfor (const clientId of clientsIds) {\r\n\t\t\tconst client = this.realm.getClientById(clientId);\r\n\r\n\t\t\tif (!client) continue;\r\n\r\n\t\t\tconst timeSinceLastPing = now - client.getLastPing();\r\n\r\n\t\t\tif (timeSinceLastPing < aliveTimeout) continue;\r\n\r\n\t\t\ttry {\r\n\t\t\t\tclient.getSocket()?.close();\r\n\t\t\t} finally {\r\n\t\t\t\tthis.realm.clearMessageQueue(clientId);\r\n\t\t\t\tthis.realm.removeClientById(clientId);\r\n\r\n\t\t\t\tclient.setSocket(null);\r\n\r\n\t\t\t\tthis.onClose?.(client);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","export enum Errors {\r\n\tINVALID_KEY = \"Invalid key provided\",\r\n\tINVALID_TOKEN = \"Invalid token provided\",\r\n\tINVALID_WS_PARAMETERS = \"No id, token, or key supplied to websocket server\",\r\n\tCONNECTION_LIMIT_EXCEED = \"Server has reached its concurrent user limit\",\r\n}\r\n\r\nexport enum MessageType {\r\n\tOPEN = \"OPEN\",\r\n\tLEAVE = \"LEAVE\",\r\n\tCANDIDATE = \"CANDIDATE\",\r\n\tOFFER = \"OFFER\",\r\n\tANSWER = \"ANSWER\",\r\n\tEXPIRE = \"EXPIRE\",\r\n\tHEARTBEAT = \"HEARTBEAT\",\r\n\tID_TAKEN = \"ID-TAKEN\",\r\n\tERROR = \"ERROR\",\r\n}\r\n","import { MessageType } from \"../../enums\";\r\nimport type { IConfig } from \"../../config\";\r\nimport type { IMessageHandler } from \"../../messageHandler\";\r\nimport type { IRealm } from \"../../models/realm\";\r\n\r\nexport interface IMessagesExpire {\r\n\tstartMessagesExpiration(): void;\r\n\tstopMessagesExpiration(): void;\r\n}\r\n\r\ntype CustomConfig = Pick<IConfig, \"cleanup_out_msgs\" | \"expire_timeout\">;\r\n\r\nexport class MessagesExpire implements IMessagesExpire {\r\n\tprivate readonly realm: IRealm;\r\n\tprivate readonly config: CustomConfig;\r\n\tprivate readonly messageHandler: IMessageHandler;\r\n\r\n\tprivate timeoutId: NodeJS.Timeout | null = null;\r\n\r\n\tconstructor({\r\n\t\trealm,\r\n\t\tconfig,\r\n\t\tmessageHandler,\r\n\t}: {\r\n\t\trealm: IRealm;\r\n\t\tconfig: CustomConfig;\r\n\t\tmessageHandler: IMessageHandler;\r\n\t}) {\r\n\t\tthis.realm = realm;\r\n\t\tthis.config = config;\r\n\t\tthis.messageHandler = messageHandler;\r\n\t}\r\n\r\n\tpublic startMessagesExpiration(): void {\r\n\t\tif (this.timeoutId) {\r\n\t\t\tclearTimeout(this.timeoutId);\r\n\t\t}\r\n\r\n\t\t// Clean up outstanding messages\r\n\t\tthis.timeoutId = setTimeout(() => {\r\n\t\t\tthis.pruneOutstanding();\r\n\r\n\t\t\tthis.timeoutId = null;\r\n\r\n\t\t\tthis.startMessagesExpiration();\r\n\t\t}, this.config.cleanup_out_msgs);\r\n\t}\r\n\r\n\tpublic stopMessagesExpiration(): void {\r\n\t\tif (this.timeoutId) {\r\n\t\t\tclearTimeout(this.timeoutId);\r\n\t\t\tthis.timeoutId = null;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate pruneOutstanding(): void {\r\n\t\tconst destinationClientsIds = this.realm.getClientsIdsWithQueue();\r\n\r\n\t\tconst now = new Date().getTime();\r\n\t\tconst maxDiff = this.config.expire_timeout;\r\n\r\n\t\tconst seen: Record<string, boolean> = {};\r\n\r\n\t\tfor (const destinationClientId of destinationClientsIds) {\r\n\t\t\tconst messageQueue = this.realm.getMessageQueueById(destinationClientId);\r\n\r\n\t\t\tif (!messageQueue) continue;\r\n\r\n\t\t\tconst lastReadDiff = now - messageQueue.getLastReadAt();\r\n\r\n\t\t\tif (lastReadDiff < maxDiff) continue;\r\n\r\n\t\t\tconst messages = messageQueue.getMessages();\r\n\r\n\t\t\tfor (const message of messages) {\r\n\t\t\t\tconst seenKey = `${message.src}_${message.dst}`;\r\n\r\n\t\t\t\tif (!seen[seenKey]) {\r\n\t\t\t\t\tthis.messageHandler.handle(undefined, {\r\n\t\t\t\t\t\ttype: MessageType.EXPIRE,\r\n\t\t\t\t\t\tsrc: message.dst,\r\n\t\t\t\t\t\tdst: message.src,\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tseen[seenKey] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.realm.clearMessageQueue(destinationClientId);\r\n\t\t}\r\n\t}\r\n}\r\n","import type WebSocket from \"ws\";\r\n\r\nexport interface IClient {\r\n\tgetId(): string;\r\n\r\n\tgetToken(): string;\r\n\r\n\tgetSocket(): WebSocket | null;\r\n\r\n\tsetSocket(socket: WebSocket | null): void;\r\n\r\n\tgetLastPing(): number;\r\n\r\n\tsetLastPing(lastPing: number): void;\r\n\r\n\tsend<T>(data: T): void;\r\n}\r\n\r\nexport class Client implements IClient {\r\n\tprivate readonly id: string;\r\n\tprivate readonly token: string;\r\n\tprivate socket: WebSocket | null = null;\r\n\tprivate lastPing: number = new Date().getTime();\r\n\r\n\tconstructor({ id, token }: { id: string; token: string }) {\r\n\t\tthis.id = id;\r\n\t\tthis.token = token;\r\n\t}\r\n\r\n\tpublic getId(): string {\r\n\t\treturn this.id;\r\n\t}\r\n\r\n\tpublic getToken(): string {\r\n\t\treturn this.token;\r\n\t}\r\n\r\n\tpublic getSocket(): WebSocket | null {\r\n\t\treturn this.socket;\r\n\t}\r\n\r\n\tpublic setSocket(socket: WebSocket | null): void {\r\n\t\tthis.socket = socket;\r\n\t}\r\n\r\n\tpublic getLastPing(): number {\r\n\t\treturn this.lastPing;\r\n\t}\r\n\r\n\tpublic setLastPing(lastPing: number): void {\r\n\t\tthis.lastPing = lastPing;\r\n\t}\r\n\r\n\tpublic send<T>(data: T): void {\r\n\t\tthis.socket?.send(JSON.stringify(data));\r\n\t}\r\n}\r\n","import { EventEmitter } from \"node:events\";\r\nimport type { IncomingMessage } from \"node:http\";\r\nimport url from \"node:url\";\r\nimport type WebSocket from \"ws\";\r\nimport { Errors, MessageType } from \"../../enums\";\r\nimport type { IClient } from \"../../models/client\";\r\nimport { Client } from \"../../models/client\";\r\nimport type { IConfig } from \"../../config\";\r\nimport type { IRealm } from \"../../models/realm\";\r\nimport { WebSocketServer as Server } from \"ws\";\r\nimport type { Server as HttpServer } from \"node:http\";\r\nimport type { Server as HttpsServer } from \"node:https\";\r\n\r\nexport interface IWebSocketServer extends EventEmitter {\r\n\treadonly path: string;\r\n}\r\n\r\ninterface IAuthParams {\r\n\tid?: string;\r\n\ttoken?: string;\r\n\tkey?: string;\r\n}\r\n\r\ntype CustomConfig = Pick<\r\n\tIConfig,\r\n\t\"path\" | \"key\" | \"concurrent_limit\" | \"createWebSocketServer\"\r\n>;\r\n\r\nconst WS_PATH = \"peerjs\";\r\n\r\nexport class WebSocketServer extends EventEmitter implements IWebSocketServer {\r\n\tpublic readonly path: string;\r\n\tprivate readonly realm: IRealm;\r\n\tprivate readonly config: CustomConfig;\r\n\tpublic readonly socketServer: Server;\r\n\r\n\tconstructor({\r\n\t\tserver,\r\n\t\trealm,\r\n\t\tconfig,\r\n\t}: {\r\n\t\tserver: HttpServer | HttpsServer;\r\n\t\trealm: IRealm;\r\n\t\tconfig: CustomConfig;\r\n\t}) {\r\n\t\tsuper();\r\n\r\n\t\tthis.setMaxListeners(0);\r\n\r\n\t\tthis.realm = realm;\r\n\t\tthis.config = config;\r\n\r\n\t\tconst path = this.config.path;\r\n\t\tthis.path = `${path}${path.endsWith(\"/\") ? \"\" : \"/\"}${WS_PATH}`;\r\n\r\n\t\tconst options: WebSocket.ServerOptions = {\r\n\t\t\tpath: this.path,\r\n\t\t\tserver,\r\n\t\t};\r\n\r\n\t\tthis.socketServer = config.createWebSocketServer\r\n\t\t\t? config.createWebSocketServer(options)\r\n\t\t\t: new Server(options);\r\n\r\n\t\tthis.socketServer.on(\"connection\", (socket, req) =>\r\n\t\t\tthis._onSocketConnection(socket, req),\r\n\t\t);\r\n\t\tthis.socketServer.on(\"error\", (error: Error) => this._onSocketError(error));\r\n\t}\r\n\r\n\tprivate _onSocketConnection(socket: WebSocket, req: IncomingMessage): void {\r\n\t\t// An unhandled socket error might crash the server. Handle it first.\r\n\t\tsocket.on(\"error\", (error) => this._onSocketError(error));\r\n\r\n\t\tconst { query = {} } = url.parse(req.url ?? \"\", true);\r\n\r\n\t\tconst { id, token, key }: IAuthParams = query;\r\n\r\n\t\tif (!id || !token || !key) {\r\n\t\t\treturn this._sendErrorAndClose(socket, Errors.INVALID_WS_PARAMETERS);\r\n\t\t}\r\n\r\n\t\tif (key !== this.config.key) {\r\n\t\t\treturn this._sendErrorAndClose(socket, Errors.INVALID_KEY);\r\n\t\t}\r\n\r\n\t\tconst client = this.realm.getClientById(id);\r\n\r\n\t\tif (client) {\r\n\t\t\tif (token !== client.getToken()) {\r\n\t\t\t\t// ID-taken, invalid token\r\n\t\t\t\tsocket.send(\r\n\t\t\t\t\tJSON.stringify({\r\n\t\t\t\t\t\ttype: MessageType.ID_TAKEN,\r\n\t\t\t\t\t\tpayload: { msg: \"ID is taken\" },\r\n\t\t\t\t\t}),\r\n\t\t\t\t);\r\n\r\n\t\t\t\treturn socket.close();\r\n\t\t\t}\r\n\r\n\t\t\treturn this._configureWS(socket, client);\r\n\t\t}\r\n\r\n\t\tthis._registerClient({ socket, id, token });\r\n\t}\r\n\r\n\tprivate _onSocketError(error: Error): void {\r\n\t\t// handle error\r\n\t\tthis.emit(\"error\", error);\r\n\t}\r\n\r\n\tprivate _registerClient({\r\n\t\tsocket,\r\n\t\tid,\r\n\t\ttoken,\r\n\t}: {\r\n\t\tsocket: WebSocket;\r\n\t\tid: string;\r\n\t\ttoken: string;\r\n\t}): void {\r\n\t\t// Check concurrent limit\r\n\t\tconst clientsCount = this.realm.getClientsIds().length;\r\n\r\n\t\tif (clientsCount >= this.config.concurrent_limit) {\r\n\t\t\treturn this._sendErrorAndClose(socket, Errors.CONNECTION_LIMIT_EXCEED);\r\n\t\t}\r\n\r\n\t\tconst newClient: IClient = new Client({ id, token });\r\n\t\tthis.realm.setClient(newClient, id);\r\n\t\tsocket.send(JSON.stringify({ type: MessageType.OPEN }));\r\n\r\n\t\tthis._configureWS(socket, newClient);\r\n\t}\r\n\r\n\tprivate _configureWS(socket: WebSocket, client: IClient): void {\r\n\t\tclient.setSocket(socket);\r\n\r\n\t\t// Cleanup after a socket closes.\r\n\t\tsocket.on(\"close\", () => {\r\n\t\t\tif (client.getSocket() === socket) {\r\n\t\t\t\tthis.realm.removeClientById(client.getId());\r\n\t\t\t\tthis.emit(\"close\", client);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Handle messages from peers.\r\n\t\tsocket.on(\"message\", (data) => {\r\n\t\t\ttry {\r\n\t\t\t\tconst message = JSON.parse(data.toString());\r\n\r\n\t\t\t\tmessage.src = client.getId();\r\n\r\n\t\t\t\tthis.emit(\"message\", client, message);\r\n\t\t\t} catch (e) {\r\n\t\t\t\tthis.emit(\"error\", e);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.emit(\"connection\", client);\r\n\t}\r\n\r\n\tprivate _sendErrorAndClose(socket: WebSocket, msg: Errors): void {\r\n\t\tsocket.send(\r\n\t\t\tJSON.stringify({\r\n\t\t\t\ttype: MessageType.ERROR,\r\n\t\t\t\tpayload: { msg },\r\n\t\t\t}),\r\n\t\t);\r\n\r\n\t\tsocket.close();\r\n\t}\r\n}\r\n","import type { IClient } from \"../../../models/client\";\r\n\r\nexport const HeartbeatHandler = (client: IClient | undefined): boolean => {\r\n\tif (client) {\r\n\t\tconst nowTime = new Date().getTime();\r\n\t\tclient.setLastPing(nowTime);\r\n\t}\r\n\r\n\treturn true;\r\n};\r\n","import { MessageType } from \"../../../enums\";\r\nimport type { IClient } from \"../../../models/client\";\r\nimport type { IMessage } from \"../../../models/message\";\r\nimport type { IRealm } from \"../../../models/realm\";\r\n\r\nexport const TransmissionHandler = ({\r\n\trealm,\r\n}: {\r\n\trealm: IRealm;\r\n}): ((client: IClient | undefined, message: IMessage) => boolean) => {\r\n\tconst handle = (client: IClient | undefined, message: IMessage) => {\r\n\t\tconst type = message.type;\r\n\t\tconst srcId = message.src;\r\n\t\tconst dstId = message.dst;\r\n\r\n\t\tconst destinationClient = realm.getClientById(dstId);\r\n\r\n\t\t// User is connected!\r\n\t\tif (destinationClient) {\r\n\t\t\tconst socket = destinationClient.getSocket();\r\n\t\t\ttry {\r\n\t\t\t\tif (socket) {\r\n\t\t\t\t\tconst data = JSON.stringify(message);\r\n\r\n\t\t\t\t\tsocket.send(data);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Neither socket no res available. Peer dead?\r\n\t\t\t\t\tthrow new Error(\"Peer dead\");\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// This happens when a peer disconnects without closing connections and\r\n\t\t\t\t// the associated WebSocket has not closed.\r\n\t\t\t\t// Tell other side to stop trying.\r\n\t\t\t\tif (socket) {\r\n\t\t\t\t\tsocket.close();\r\n\t\t\t\t} else {\r\n\t\t\t\t\trealm.removeClientById(destinationClient.getId());\r\n\t\t\t\t}\r\n\r\n\t\t\t\thandle(client, {\r\n\t\t\t\t\ttype: MessageType.LEAVE,\r\n\t\t\t\t\tsrc: dstId,\r\n\t\t\t\t\tdst: srcId,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Wait for this client to connect/reconnect (XHR) for important\r\n\t\t\t// messages.\r\n\t\t\tconst ignoredTypes = [MessageType.LEAVE, MessageType.EXPIRE];\r\n\r\n\t\t\tif (!ignoredTypes.includes(type) && dstId) {\r\n\t\t\t\trealm.addMessageToQueue(dstId, message);\r\n\t\t\t} else if (type === MessageType.LEAVE && !dstId) {\r\n\t\t\t\trealm.removeClientById(srcId);\r\n\t\t\t} else {\r\n\t\t\t\t// Unavailable destination specified with message LEAVE or EXPIRE\r\n\t\t\t\t// Ignore\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\treturn handle;\r\n};\r\n","import type { MessageType } from \"../enums\";\r\nimport type { IClient } from \"../models/client\";\r\nimport type { IMessage } from \"../models/message\";\r\nimport type { Handler } from \"./handler\";\r\n\r\nexport interface IHandlersRegistry {\r\n\tregisterHandler(messageType: MessageType, handler: Handler): void;\r\n\thandle(client: IClient | undefined, message: IMessage): boolean;\r\n}\r\n\r\nexport class HandlersRegistry implements IHandlersRegistry {\r\n\tprivate readonly handlers: Map<MessageType, Handler> = new Map();\r\n\r\n\tpublic registerHandler(messageType: MessageType, handler: Handler): void {\r\n\t\tif (this.handlers.has(messageType)) return;\r\n\r\n\t\tthis.handlers.set(messageType, handler);\r\n\t}\r\n\r\n\tpublic handle(client: IClient | undefined, message: IMessage): boolean {\r\n\t\tconst { type } = message;\r\n\r\n\t\tconst handler = this.handlers.get(type);\r\n\r\n\t\tif (!handler) return false;\r\n\r\n\t\treturn handler(client, message);\r\n\t}\r\n}\r\n","import { MessageType } from \"../enums\";\r\nimport { HeartbeatHandler, TransmissionHandler } from \"./handlers\";\r\nimport type { IHandlersRegistry } from \"./handlersRegistry\";\r\nimport { HandlersRegistry } from \"./handlersRegistry\";\r\nimport type { IClient } from \"../models/client\";\r\nimport type { IMessage } from \"../models/message\";\r\nimport type { IRealm } from \"../models/realm\";\r\nimport type { Handler } from \"./handler\";\r\n\r\nexport interface IMessageHandler {\r\n\thandle(client: IClient | undefined, message: IMessage): boolean;\r\n}\r\n\r\nexport class MessageHandler implements IMessageHandler {\r\n\tconstructor(\r\n\t\trealm: IRealm,\r\n\t\tprivate readonly handlersRegistry: IHandlersRegistry = new HandlersRegistry(),\r\n\t) {\r\n\t\tconst transmissionHandler: Handler = TransmissionHandler({ realm });\r\n\t\tconst heartbeatHandler: Handler = HeartbeatHandler;\r\n\r\n\t\tconst handleTransmission: Handler = (\r\n\t\t\tclient: IClient | undefined,\r\n\t\t\t{ type, src, dst, payload }: IMessage,\r\n\t\t): boolean => {\r\n\t\t\treturn transmissionHandler(client, {\r\n\t\t\t\ttype,\r\n\t\t\t\tsrc,\r\n\t\t\t\tdst,\r\n\t\t\t\tpayload,\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\tconst handleHeartbeat = (client: IClient | undefined, message: IMessage) =>\r\n\t\t\theartbeatHandler(client, message);\r\n\r\n\t\tthis.handlersRegistry.registerHandler(\r\n\t\t\tMessageType.HEARTBEAT,\r\n\t\t\thandleHeartbeat,\r\n\t\t);\r\n\t\tthis.handlersRegistry.registerHandler(\r\n\t\t\tMessageType.OFFER,\r\n\t\t\thandleTransmission,\r\n\t\t);\r\n\t\tthis.handlersRegistry.registerHandler(\r\n\t\t\tMessageType.ANSWER,\r\n\t\t\thandleTransmission,\r\n\t\t);\r\n\t\tthis.handlersRegistry.registerHandler(\r\n\t\t\tMessageType.CANDIDATE,\r\n\t\t\thandleTransmission,\r\n\t\t);\r\n\t\tthis.handlersRegistry.registerHandler(\r\n\t\t\tMessageType.LEAVE,\r\n\t\t\thandleTransmission,\r\n\t\t);\r\n\t\tthis.handlersRegistry.registerHandler(\r\n\t\t\tMessageType.EXPIRE,\r\n\t\t\thandleTransmission,\r\n\t\t);\r\n\t}\r\n\r\n\tpublic handle(client: IClient | undefined, message: IMessage): boolean {\r\n\t\treturn this.handlersRegistry.handle(client, message);\r\n\t}\r\n}\r\n","{\r\n\t\"name\": \"PeerJS Server\",\r\n\t\"description\": \"A server side element to broker connections between PeerJS clients.\",\r\n\t\"website\": \"https://peerjs.com/\"\r\n}\r\n","import express from \"express\";\r\nimport type { IConfig } from \"../../../config\";\r\nimport type { IRealm } from \"../../../models/realm\";\r\n\r\nexport default ({\r\n\tconfig,\r\n\trealm,\r\n}: {\r\n\tconfig: IConfig;\r\n\trealm: IRealm;\r\n}): express.Router => {\r\n\tconst app = express.Router();\r\n\r\n\t// Retrieve guaranteed random ID.\r\n\tapp.get(\"/id\", (_, res: express.Response) => {\r\n\t\tres.contentType(\"html\");\r\n\t\tres.send(realm.generateClientId(config.generateClientId));\r\n\t});\r\n\r\n\t// Get a list of all peers for a key, enabled by the `allowDiscovery` flag.\r\n\tapp.get(\"/peers\", (_, res: express.Response) => {\r\n\t\tif (config.allow_discovery) {\r\n\t\t\tconst clientsIds = realm.getClientsIds();\r\n\r\n\t\t\treturn res.send(clientsIds);\r\n\t\t}\r\n\r\n\t\treturn res.sendStatus(401);\r\n\t});\r\n\r\n\treturn app;\r\n};\r\n","import cors, { CorsOptions } from \"cors\";\r\nimport express from \"express\";\r\nimport publicContent from \"../../app.json\";\r\nimport PublicApi from \"./v1/public\";\r\nimport type { IConfig } from \"../config\";\r\nimport type { IRealm } from \"../models/realm\";\r\n\r\nexport const Api = ({\r\n\tconfig,\r\n\trealm,\r\n\tcorsOptions,\r\n}: {\r\n\tconfig: IConfig;\r\n\trealm: IRealm;\r\n\tcorsOptions: CorsOptions;\r\n}): express.Router => {\r\n\tconst app = express.Router();\r\n\r\n\tapp.use(cors(corsOptions));\r\n\r\n\tapp.get(\"/\", (_, res) => {\r\n\t\tres.send(publicContent);\r\n\t});\r\n\r\n\tapp.use(\"/:key\", PublicApi({ config, realm }));\r\n\r\n\treturn app;\r\n};\r\n","import type express from \"express\";\r\nimport type { Server as HttpServer } from \"node:http\";\r\nimport type { Server as HttpsServer } from \"node:https\";\r\nimport path from \"node:path\";\r\nimport type { IRealm } from \"./models/realm\";\r\nimport { Realm } from \"./models/realm\";\r\nimport { CheckBrokenConnections } from \"./services/checkBrokenConnections\";\r\nimport type { IMessagesExpire } from \"./services/messagesExpire\";\r\nimport { MessagesExpire } from \"./services/messagesExpire\";\r\nimport type { IWebSocketServer } from \"./services/webSocketServer\";\r\nimport { WebSocketServer } from \"./services/webSocketServer\";\r\nimport { MessageHandler } from \"./messageHandler\";\r\nimport { Api } from \"./api\";\r\nimport type { IClient } from \"./models/client\";\r\nimport type { IMessage } from \"./models/message\";\r\nimport type { IConfig } from \"./config\";\r\n\r\nexport interface PeerServerEvents {\r\n\ton(event: \"connection\", listener: (client: IClient) => void): this;\r\n\ton(\r\n\t\tevent: \"message\",\r\n\t\tlistener: (client: IClient, message: IMessage) => void,\r\n\t): this;\r\n\ton(event: \"disconnect\", listener: (client: IClient) => void): this;\r\n\ton(event: \"error\", listener: (client: Error) => void): this;\r\n}\r\n\r\nexport const createInstance = ({\r\n\tapp,\r\n\tserver,\r\n\toptions,\r\n}: {\r\n\tapp: express.Application;\r\n\tserver: HttpServer | HttpsServer;\r\n\toptions: IConfig;\r\n}): void => {\r\n\tconst config = options;\r\n\tconst realm: IRealm = new Realm();\r\n\tconst messageHandler = new MessageHandler(realm);\r\n\r\n\tconst api = Api({ config, realm, corsOptions: options.corsOptions });\r\n\tconst messagesExpire: IMessagesExpire = new MessagesExpire({\r\n\t\trealm,\r\n\t\tconfig,\r\n\t\tmessageHandler,\r\n\t});\r\n\tconst checkBrokenConnections = new CheckBrokenConnections({\r\n\t\trealm,\r\n\t\tconfig,\r\n\t\tonClose: (client) => {\r\n\t\t\tapp.emit(\"disconnect\", client);\r\n\t\t},\r\n\t});\r\n\r\n\tapp.use(options.path, api);\r\n\r\n\t//use mountpath for WS server\r\n\tconst customConfig = {\r\n\t\t...config,\r\n\t\tpath: path.posix.join(app.path(), options.path, \"/\"),\r\n\t};\r\n\r\n\tconst wss: IWebSocketServer = new WebSocketServer({\r\n\t\tserver,\r\n\t\trealm,\r\n\t\tconfig: customConfig,\r\n\t});\r\n\r\n\twss.on(\"connection\", (client: IClient) => {\r\n\t\tconst messageQueue = realm.getMessageQueueById(client.getId());\r\n\r\n\t\tif (messageQueue) {\r\n\t\t\tlet message: IMessage | undefined;\r\n\r\n\t\t\twhile ((message = messageQueue.readMessage())) {\r\n\t\t\t\tmessageHandler.handle(client, message);\r\n\t\t\t}\r\n\t\t\trealm.clearMessageQueue(client.getId());\r\n\t\t}\r\n\r\n\t\tapp.emit(\"connection\", client);\r\n\t});\r\n\r\n\twss.on(\"message\", (client: IClient, message: IMessage) => {\r\n\t\tapp.emit(\"message\", client, message);\r\n\t\tmessageHandler.handle(client, message);\r\n\t});\r\n\r\n\twss.on(\"close\", (client: IClient) => {\r\n\t\tapp.emit(\"disconnect\", client);\r\n\t});\r\n\r\n\twss.on(\"error\", (error: Error) => {\r\n\t\tapp.emit(\"error\", error);\r\n\t});\r\n\r\n\tmessagesExpire.startMessagesExpiration();\r\n\tcheckBrokenConnections.start();\r\n};\r\n","#!/usr/bin/env node\r\n\r\nimport path from \"node:path\";\r\nimport { version } from \"../package.json\";\r\nimport fs from \"node:fs\";\r\nconst optimistUsageLength = 98;\r\nimport yargs from \"yargs\";\r\nimport { hideBin } from \"yargs/helpers\";\r\nimport { PeerServer } from \"../src\";\r\nimport type { AddressInfo } from \"node:net\";\r\nimport type { CorsOptions } from \"cors\";\r\n\r\nconst y = yargs(hideBin(process.argv));\r\n\r\nconst portEnvIsSet = !!process.env[\"PORT\"];\r\n\r\nconst opts = y\r\n\t.usage(\"Usage: $0\")\r\n\t.wrap(Math.min(optimistUsageLength, y.terminalWidth()))\r\n\t.options({\r\n\t\texpire_timeout: {\r\n\t\t\tdemandOption: false,\r\n\t\t\talias: \"t\",\r\n\t\t\tdescribe: \"timeout (milliseconds)\",\r\n\t\t\tdefault: 5000,\r\n\t\t},\r\n\t\tconcurrent_limit: {\r\n\t\t\tdemandOption: false,\r\n\t\t\talias: \"c\",\r\n\t\t\tdescribe: \"concurrent limit\",\r\n\t\t\tdefault: 5000,\r\n\t\t},\r\n\t\talive_timeout: {\r\n\t\t\tdemandOption: false,\r\n\t\t\tdescribe: \"broken connection check timeout (milliseconds)\",\r\n\t\t\tdefault: 60000,\r\n\t\t},\r\n\t\tkey: {\r\n\t\t\tdemandOption: false,\r\n\t\t\talias: \"k\",\r\n\t\t\tdescribe: \"connection key\",\r\n\t\t\tdefault: \"peerjs\",\r\n\t\t},\r\n\t\tsslkey: {\r\n\t\t\ttype: \"string\",\r\n\t\t\tdemandOption: false,\r\n\t\t\tdescribe: \"path to SSL key\",\r\n\t\t},\r\n\t\tsslcert: {\r\n\t\t\ttype: \"string\",\r\n\t\t\tdemandOption: false,\r\n\t\t\tdescribe: \"path to SSL certificate\",\r\n\t\t},\r\n\t\thost: {\r\n\t\t\ttype: \"string\",\r\n\t\t\tdemandOption: false,\r\n\t\t\talias: \"H\",\r\n\t\t\tdescribe: \"host\",\r\n\t\t},\r\n\t\tport: {\r\n\t\t\ttype: \"number\",\r\n\t\t\tdemandOption: !portEnvIsSet,\r\n\t\t\talias: \"p\",\r\n\t\t\tdescribe: \"port\",\r\n\t\t},\r\n\t\tpath: {\r\n\t\t\ttype: \"string\",\r\n\t\t\tdemandOption: false,\r\n\t\t\tdescribe: \"custom path\",\r\n\t\t\tdefault: process.env[\"PEERSERVER_PATH\"] || \"/\",\r\n\t\t},\r\n\t\tallow_discovery: {\r\n\t\t\ttype: \"boolean\",\r\n\t\t\tdemandOption: false,\r\n\t\t\tdescribe: \"allow discovery of peers\",\r\n\t\t},\r\n\t\tproxied: {\r\n\t\t\ttype: \"boolean\",\r\n\t\t\tdemandOption: false,\r\n\t\t\tdescribe: \"Set true if PeerServer stays behind a reverse proxy\",\r\n\t\t\tdefault: false,\r\n\t\t},\r\n\t\tcors: {\r\n\t\t\ttype: \"string\",\r\n\t\t\tarray: true,\r\n\t\t\tdescribe: \"Set the list of CORS origins\",\r\n\t\t},\r\n\t})\r\n\t.boolean(\"allow_discovery\")\r\n\t.parseSync();\r\n\r\nif (!opts.port) {\r\n\topts.port = parseInt(process.env[\"PORT\"] as string);\r\n}\r\nif (opts.cors) {\r\n\topts[\"corsOptions\"] = {\r\n\t\torigin: opts.cors,\r\n\t} satisfies CorsOptions;\r\n}\r\nprocess.on(\"uncaughtException\", function (e) {\r\n\tconsole.error(\"Error: \" + e);\r\n});\r\n\r\nif (opts.sslkey || opts.sslcert) {\r\n\tif (opts.sslkey && opts.sslcert) {\r\n\t\topts[\"ssl\"] = {\r\n\t\t\tkey: fs.readFileSync(path.resolve(opts.sslkey)),\r\n\t\t\tcert: fs.readFileSync(path.resolve(opts.sslcert)),\r\n\t\t};\r\n\t} else {\r\n\t\tconsole.error(\r\n\t\t\t\"Warning: PeerServer will not run because either \" +\r\n\t\t\t\t\"the key or the certificate has not been provided.\",\r\n\t\t);\r\n\t\tprocess.exit(1);\r\n\t}\r\n}\r\n\r\nconst userPath = opts.path;\r\nconst server = PeerServer(opts, (server) => {\r\n\tconst { address: host, port } = server.address() as AddressInfo;\r\n\r\n\tconsole.log(\r\n\t\t\"Started PeerServer on %s, port: %s, path: %s (v. %s)\",\r\n\t\thost,\r\n\t\tport,\r\n\t\tuserPath || \"/\",\r\n\t\tversion,\r\n\t);\r\n\r\n\tconst shutdownApp = () => {\r\n\t\tserver.close(() => {\r\n\t\t\tconsole.log(\"Http server closed.\");\r\n\r\n\t\t\tprocess.exit(0);\r\n\t\t});\r\n\t};\r\n\r\n\tprocess.on(\"SIGINT\", shutdownApp);\r\n\tprocess.on(\"SIGTERM\", shutdownApp);\r\n});\r\n\r\nserver.on(\"connection\", (client) => {\r\n\tconsole.log(`Client connected: ${client.getId()}`);\r\n});\r\n\r\nserver.on(\"disconnect\", (client) => {\r\n\tconsole.log(`Client disconnected: ${client.getId()}`);\r\n});\r\n","import express, { type Express } from \"express\";\r\nimport http from \"node:http\";\r\nimport https from \"node:https\";\r\n\r\nimport type { IConfig } from \"./config\";\r\nimport defaultConfig from \"./config\";\r\nimport type { PeerServerEvents } from \"./instance\";\r\nimport { createInstance } from \"./instance\";\r\nimport type { IClient } from \"./models/client\";\r\nimport type { IMessage } from \"./models/message\";\r\n\r\nexport type { MessageType } from \"./enums\";\r\nexport type { IConfig, PeerServerEvents, IClient, IMessage };\r\n\r\nfunction ExpressPeerServer(\r\n\tserver: https.Server | http.Server,\r\n\toptions?: Partial<IConfig>,\r\n) {\r\n\tconst app = express();\r\n\r\n\tconst newOptions: IConfig = {\r\n\t\t...defaultConfig,\r\n\t\t...options,\r\n\t};\r\n\r\n\tif (newOptions.proxied) {\r\n\t\tapp.set(\r\n\t\t\t\"trust proxy\",\r\n\t\t\tnewOptions.proxied === \"false\" ? false : !!newOptions.proxied,\r\n\t\t);\r\n\t}\r\n\r\n\tapp.on(\"mount\", () => {\r\n\t\tif (!server) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t\"Server is not passed to constructor - \" + \"can't start PeerServer\",\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tcreateInstance({ app, server, options: newOptions });\r\n\t});\r\n\r\n\treturn app as Express & PeerServerEvents;\r\n}\r\n\r\nfunction PeerServer(\r\n\toptions: Partial<IConfig> = {},\r\n\tcallback?: (server: https.Server | http.Server) => void,\r\n) {\r\n\tconst app = express();\r\n\r\n\tlet newOptions: IConfig = {\r\n\t\t...defaultConfig,\r\n\t\t...options,\r\n\t};\r\n\r\n\tconst port = newOptions.port;\r\n\tconst host = newOptions.host;\r\n\r\n\tlet server: https.Server | http.Server;\r\n\r\n\tconst { ssl, ...restOptions } = newOptions;\r\n\tif (ssl && Object.keys(ssl).length) {\r\n\t\tserver = https.createServer(ssl, app);\r\n\r\n\t\tnewOptions = restOptions;\r\n\t} else {\r\n\t\tserver = http.createServer(app);\r\n\t}\r\n\r\n\tconst peerjs = ExpressPeerServer(server, newOptions);\r\n\tapp.use(peerjs);\r\n\r\n\tserver.listen(port, host, () => callback?.(server));\r\n\r\n\treturn peerjs;\r\n}\r\n\r\nexport { ExpressPeerServer, PeerServer };\r\n"],"names":["$26afa55b21e869a1$exports","JSON","parse","$aeb1147dec1b7a02$export$2e2bcd8739ae039","host","port","expire_timeout","alive_timeout","key","path","concurrent_limit","allow_discovery","proxied","cleanup_out_msgs","corsOptions","origin","$2c42eaf0ccc66758$export$eb4c623330d4cbcc","lastReadAt","Date","getTime","messages","getLastReadAt","this","addMessage","message","push","readMessage","length","shift","getMessages","$0a339ca52e0451c9$export$3ee29d34e33d9116","clients","Map","messageQueues","getClientsIds","keys","getClientById","clientId","get","getClientsIdsWithQueue","setClient","client","id","set","removeClientById","delete","getMessageQueueById","addMessageToQueue","clearMessageQueue","generateClientId","generateId","$7BbP7$randomUUID","$6840aafc61c9abd6$export$6fa53df6b5b88df7","timeoutId","constructor","realm","config","checkInterval","onClose","start","clearTimeout","setTimeout","checkConnections","stop","clientsIds","now","aliveTimeout","getLastPing","getSocket","close","setSocket","$d461d7260b6fc353$export$b8e9cd941e8016ac","Errors","$d461d7260b6fc353$export$80edbf15fa61a4db","MessageType","$c97baf9b78981954$export$a13b411d0e88b1af","messageHandler","startMessagesExpiration","pruneOutstanding","stopMessagesExpiration","destinationClientsIds","maxDiff","seen","destinationClientId","messageQueue","seenKey","src","dst","handle","undefined","type","EXPIRE","$d09fcb6ab78a3f48$export$1f2bb630327ac4b6","socket","lastPing","token","getId","getToken","setLastPing","send","data","stringify","$4ae24f8b3b7cf7b0$export$f47674b57e51ee3b","$7BbP7$EventEmitter","server","super","setMaxListeners","endsWith","options","socketServer","createWebSocketServer","$7BbP7$WebSocketServer","on","req","_onSocketConnection","error","_onSocketError","query","$7BbP7$nodeurl","url","_sendErrorAndClose","INVALID_WS_PARAMETERS","INVALID_KEY","ID_TAKEN","payload","msg","_configureWS","_registerClient","emit","CONNECTION_LIMIT_EXCEED","newClient","OPEN","toString","e","ERROR","$c523c19e3fc944a1$export$65302b915833a46d","nowTime","$879e80f95ec634eb$export$809c011ea942310","srcId","dstId","destinationClient","Error","LEAVE","includes","$df0509eaca4ae82c$export$cfe4a96645b0bbcf","handlers","registerHandler","messageType","handler","has","$3089a9bad51bbb04$export$3deceafe0aaeaa95","handlersRegistry","transmissionHandler","heartbeatHandler","handleTransmission","HEARTBEAT","OFFER","ANSWER","CANDIDATE","$264fdbd7932d14df$exports","$6910ff2a5db5006f$export$2e2bcd8739ae039","app","$7BbP7$express","Router","_","res","contentType","sendStatus","$69f9994c6ebd6802$export$bf71da7aebe9ddc1","use","$7BbP7$cors","$parcel$interopDefault","$e7d4fd16baa81890$export$99152e8d49ca4e7d","api","messagesExpire","checkBrokenConnections","customConfig","$7BbP7$nodepath","posix","join","wss","$3809f3d53201df9f$var$y","$7BbP7$yargs","$7BbP7$hideBin","process","argv","$3809f3d53201df9f$var$portEnvIsSet","env","$3809f3d53201df9f$var$opts","usage","wrap","Math","min","terminalWidth","demandOption","alias","describe","default","sslkey","sslcert","cors","array","boolean","parseSync","parseInt","console","$7BbP7$nodefs","readFileSync","resolve","cert","exit","$3809f3d53201df9f$var$userPath","$3809f3d53201df9f$var$server","callback","newOptions","ssl","restOptions","Object","$7BbP7$nodehttps","createServer","$7BbP7$nodehttp","peerjs","$0fe9c43b5c368182$export$8c57434a18c696c9","listen","address","log","version","shutdownApp"],"version":3,"file":"peerjs.js.map","sourceRoot":"../../"}
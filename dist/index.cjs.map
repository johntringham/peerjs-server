{"mappings":"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","sources":["src/index.ts","src/config/index.ts","src/instance.ts","src/models/realm.ts","src/models/messageQueue.ts","src/services/checkBrokenConnections/index.ts","src/services/messagesExpire/index.ts","src/enums.ts","src/services/webSocketServer/index.ts","src/models/client.ts","src/messageHandler/index.ts","src/messageHandler/handlers/index.ts","src/messageHandler/handlers/heartbeat/index.ts","src/messageHandler/handlers/transmission/index.ts","src/messageHandler/handlersRegistry.ts","src/api/index.ts","app.json","src/api/v1/public/index.ts"],"sourcesContent":["import express, { type Express } from \"express\";\r\nimport http from \"node:http\";\r\nimport https from \"node:https\";\r\n\r\nimport type { IConfig } from \"./config\";\r\nimport defaultConfig from \"./config\";\r\nimport type { PeerServerEvents } from \"./instance\";\r\nimport { createInstance } from \"./instance\";\r\nimport type { IClient } from \"./models/client\";\r\nimport type { IMessage } from \"./models/message\";\r\n\r\nexport type { MessageType } from \"./enums\";\r\nexport type { IConfig, PeerServerEvents, IClient, IMessage };\r\n\r\nfunction ExpressPeerServer(\r\n\tserver: https.Server | http.Server,\r\n\toptions?: Partial<IConfig>,\r\n) {\r\n\tconst app = express();\r\n\r\n\tconst newOptions: IConfig = {\r\n\t\t...defaultConfig,\r\n\t\t...options,\r\n\t};\r\n\r\n\tif (newOptions.proxied) {\r\n\t\tapp.set(\r\n\t\t\t\"trust proxy\",\r\n\t\t\tnewOptions.proxied === \"false\" ? false : !!newOptions.proxied,\r\n\t\t);\r\n\t}\r\n\r\n\tapp.on(\"mount\", () => {\r\n\t\tif (!server) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t\"Server is not passed to constructor - \" + \"can't start PeerServer\",\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tcreateInstance({ app, server, options: newOptions });\r\n\t});\r\n\r\n\treturn app as Express & PeerServerEvents;\r\n}\r\n\r\nfunction PeerServer(\r\n\toptions: Partial<IConfig> = {},\r\n\tcallback?: (server: https.Server | http.Server) => void,\r\n) {\r\n\tconst app = express();\r\n\r\n\tlet newOptions: IConfig = {\r\n\t\t...defaultConfig,\r\n\t\t...options,\r\n\t};\r\n\r\n\tconst port = newOptions.port;\r\n\tconst host = newOptions.host;\r\n\r\n\tlet server: https.Server | http.Server;\r\n\r\n\tconst { ssl, ...restOptions } = newOptions;\r\n\tif (ssl && Object.keys(ssl).length) {\r\n\t\tserver = https.createServer(ssl, app);\r\n\r\n\t\tnewOptions = restOptions;\r\n\t} else {\r\n\t\tserver = http.createServer(app);\r\n\t}\r\n\r\n\tconst peerjs = ExpressPeerServer(server, newOptions);\r\n\tapp.use(peerjs);\r\n\r\n\tserver.listen(port, host, () => callback?.(server));\r\n\r\n\treturn peerjs;\r\n}\r\n\r\nexport { ExpressPeerServer, PeerServer };\r\n","import type { WebSocketServer, ServerOptions } from \"ws\";\r\nimport type { CorsOptions } from \"cors\";\r\n\r\nexport interface IConfig {\r\n\treadonly host: string;\r\n\treadonly port: number;\r\n\treadonly expire_timeout: number;\r\n\treadonly alive_timeout: number;\r\n\treadonly key: string;\r\n\treadonly path: string;\r\n\treadonly concurrent_limit: number;\r\n\treadonly allow_discovery: boolean;\r\n\treadonly proxied: boolean | string;\r\n\treadonly cleanup_out_msgs: number;\r\n\treadonly ssl?: {\r\n\t\tkey: string;\r\n\t\tcert: string;\r\n\t};\r\n\treadonly generateClientId?: () => string;\r\n\treadonly createWebSocketServer?: (options: ServerOptions) => WebSocketServer;\r\n\treadonly corsOptions: CorsOptions;\r\n}\r\n\r\nconst defaultConfig: IConfig = {\r\n\thost: \"::\",\r\n\tport: 9000,\r\n\texpire_timeout: 5000,\r\n\talive_timeout: 60000,\r\n\tkey: \"peerjs\",\r\n\tpath: \"/\",\r\n\tconcurrent_limit: 5000,\r\n\tallow_discovery: false,\r\n\tproxied: false,\r\n\tcleanup_out_msgs: 1000,\r\n\tcorsOptions: { origin: true },\r\n};\r\n\r\nexport default defaultConfig;\r\n","import type express from \"express\";\r\nimport type { Server as HttpServer } from \"node:http\";\r\nimport type { Server as HttpsServer } from \"node:https\";\r\nimport path from \"node:path\";\r\nimport type { IRealm } from \"./models/realm\";\r\nimport { Realm } from \"./models/realm\";\r\nimport { CheckBrokenConnections } from \"./services/checkBrokenConnections\";\r\nimport type { IMessagesExpire } from \"./services/messagesExpire\";\r\nimport { MessagesExpire } from \"./services/messagesExpire\";\r\nimport type { IWebSocketServer } from \"./services/webSocketServer\";\r\nimport { WebSocketServer } from \"./services/webSocketServer\";\r\nimport { MessageHandler } from \"./messageHandler\";\r\nimport { Api } from \"./api\";\r\nimport type { IClient } from \"./models/client\";\r\nimport type { IMessage } from \"./models/message\";\r\nimport type { IConfig } from \"./config\";\r\n\r\nexport interface PeerServerEvents {\r\n\ton(event: \"connection\", listener: (client: IClient) => void): this;\r\n\ton(\r\n\t\tevent: \"message\",\r\n\t\tlistener: (client: IClient, message: IMessage) => void,\r\n\t): this;\r\n\ton(event: \"disconnect\", listener: (client: IClient) => void): this;\r\n\ton(event: \"error\", listener: (client: Error) => void): this;\r\n}\r\n\r\nexport const createInstance = ({\r\n\tapp,\r\n\tserver,\r\n\toptions,\r\n}: {\r\n\tapp: express.Application;\r\n\tserver: HttpServer | HttpsServer;\r\n\toptions: IConfig;\r\n}): void => {\r\n\tconst config = options;\r\n\tconst realm: IRealm = new Realm();\r\n\tconst messageHandler = new MessageHandler(realm);\r\n\r\n\tconst api = Api({ config, realm, corsOptions: options.corsOptions });\r\n\tconst messagesExpire: IMessagesExpire = new MessagesExpire({\r\n\t\trealm,\r\n\t\tconfig,\r\n\t\tmessageHandler,\r\n\t});\r\n\tconst checkBrokenConnections = new CheckBrokenConnections({\r\n\t\trealm,\r\n\t\tconfig,\r\n\t\tonClose: (client) => {\r\n\t\t\tapp.emit(\"disconnect\", client);\r\n\t\t},\r\n\t});\r\n\r\n\tapp.use(options.path, api);\r\n\r\n\t//use mountpath for WS server\r\n\tconst customConfig = {\r\n\t\t...config,\r\n\t\tpath: path.posix.join(app.path(), options.path, \"/\"),\r\n\t};\r\n\r\n\tconst wss: IWebSocketServer = new WebSocketServer({\r\n\t\tserver,\r\n\t\trealm,\r\n\t\tconfig: customConfig,\r\n\t});\r\n\r\n\twss.on(\"connection\", (client: IClient) => {\r\n\t\tconst messageQueue = realm.getMessageQueueById(client.getId());\r\n\r\n\t\tif (messageQueue) {\r\n\t\t\tlet message: IMessage | undefined;\r\n\r\n\t\t\twhile ((message = messageQueue.readMessage())) {\r\n\t\t\t\tmessageHandler.handle(client, message);\r\n\t\t\t}\r\n\t\t\trealm.clearMessageQueue(client.getId());\r\n\t\t}\r\n\r\n\t\tapp.emit(\"connection\", client);\r\n\t});\r\n\r\n\twss.on(\"message\", (client: IClient, message: IMessage) => {\r\n\t\tapp.emit(\"message\", client, message);\r\n\t\tmessageHandler.handle(client, message);\r\n\t});\r\n\r\n\twss.on(\"close\", (client: IClient) => {\r\n\t\tapp.emit(\"disconnect\", client);\r\n\t});\r\n\r\n\twss.on(\"error\", (error: Error) => {\r\n\t\tapp.emit(\"error\", error);\r\n\t});\r\n\r\n\tmessagesExpire.startMessagesExpiration();\r\n\tcheckBrokenConnections.start();\r\n};\r\n","import type { IMessageQueue } from \"./messageQueue\";\r\nimport { MessageQueue } from \"./messageQueue\";\r\nimport { randomUUID } from \"node:crypto\";\r\nimport type { IClient } from \"./client\";\r\nimport type { IMessage } from \"./message\";\r\n\r\nexport interface IRealm {\r\n\tgetClientsIds(): string[];\r\n\r\n\tgetClientById(clientId: string): IClient | undefined;\r\n\r\n\tgetClientsIdsWithQueue(): string[];\r\n\r\n\tsetClient(client: IClient, id: string): void;\r\n\r\n\tremoveClientById(id: string): boolean;\r\n\r\n\tgetMessageQueueById(id: string): IMessageQueue | undefined;\r\n\r\n\taddMessageToQueue(id: string, message: IMessage): void;\r\n\r\n\tclearMessageQueue(id: string): void;\r\n\r\n\tgenerateClientId(generateClientId?: () => string): string;\r\n}\r\n\r\nexport class Realm implements IRealm {\r\n\tprivate readonly clients: Map<string, IClient> = new Map();\r\n\tprivate readonly messageQueues: Map<string, IMessageQueue> = new Map();\r\n\r\n\tpublic getClientsIds(): string[] {\r\n\t\treturn [...this.clients.keys()];\r\n\t}\r\n\r\n\tpublic getClientById(clientId: string): IClient | undefined {\r\n\t\treturn this.clients.get(clientId);\r\n\t}\r\n\r\n\tpublic getClientsIdsWithQueue(): string[] {\r\n\t\treturn [...this.messageQueues.keys()];\r\n\t}\r\n\r\n\tpublic setClient(client: IClient, id: string): void {\r\n\t\tthis.clients.set(id, client);\r\n\t}\r\n\r\n\tpublic removeClientById(id: string): boolean {\r\n\t\tconst client = this.getClientById(id);\r\n\r\n\t\tif (!client) return false;\r\n\r\n\t\tthis.clients.delete(id);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic getMessageQueueById(id: string): IMessageQueue | undefined {\r\n\t\treturn this.messageQueues.get(id);\r\n\t}\r\n\r\n\tpublic addMessageToQueue(id: string, message: IMessage): void {\r\n\t\tif (!this.getMessageQueueById(id)) {\r\n\t\t\tthis.messageQueues.set(id, new MessageQueue());\r\n\t\t}\r\n\r\n\t\tthis.getMessageQueueById(id)?.addMessage(message);\r\n\t}\r\n\r\n\tpublic clearMessageQueue(id: string): void {\r\n\t\tthis.messageQueues.delete(id);\r\n\t}\r\n\r\n\tpublic generateClientId(generateClientId?: () => string): string {\r\n\t\tconst generateId = generateClientId ? generateClientId : randomUUID;\r\n\r\n\t\tlet clientId = generateId();\r\n\r\n\t\twhile (this.getClientById(clientId)) {\r\n\t\t\tclientId = generateId();\r\n\t\t}\r\n\r\n\t\treturn clientId;\r\n\t}\r\n}\r\n","import type { IMessage } from \"./message\";\r\n\r\nexport interface IMessageQueue {\r\n\tgetLastReadAt(): number;\r\n\r\n\taddMessage(message: IMessage): void;\r\n\r\n\treadMessage(): IMessage | undefined;\r\n\r\n\tgetMessages(): IMessage[];\r\n}\r\n\r\nexport class MessageQueue implements IMessageQueue {\r\n\tprivate lastReadAt: number = new Date().getTime();\r\n\tprivate readonly messages: IMessage[] = [];\r\n\r\n\tpublic getLastReadAt(): number {\r\n\t\treturn this.lastReadAt;\r\n\t}\r\n\r\n\tpublic addMessage(message: IMessage): void {\r\n\t\tthis.messages.push(message);\r\n\t}\r\n\r\n\tpublic readMessage(): IMessage | undefined {\r\n\t\tif (this.messages.length > 0) {\r\n\t\t\tthis.lastReadAt = new Date().getTime();\r\n\t\t\treturn this.messages.shift();\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tpublic getMessages(): IMessage[] {\r\n\t\treturn this.messages;\r\n\t}\r\n}\r\n","import type { IConfig } from \"../../config\";\r\nimport type { IClient } from \"../../models/client\";\r\nimport type { IRealm } from \"../../models/realm\";\r\n\r\nconst DEFAULT_CHECK_INTERVAL = 300;\r\n\r\ntype CustomConfig = Pick<IConfig, \"alive_timeout\">;\r\n\r\nexport class CheckBrokenConnections {\r\n\tpublic readonly checkInterval: number;\r\n\tprivate timeoutId: NodeJS.Timeout | null = null;\r\n\tprivate readonly realm: IRealm;\r\n\tprivate readonly config: CustomConfig;\r\n\tprivate readonly onClose?: (client: IClient) => void;\r\n\r\n\tconstructor({\r\n\t\trealm,\r\n\t\tconfig,\r\n\t\tcheckInterval = DEFAULT_CHECK_INTERVAL,\r\n\t\tonClose,\r\n\t}: {\r\n\t\trealm: IRealm;\r\n\t\tconfig: CustomConfig;\r\n\t\tcheckInterval?: number;\r\n\t\tonClose?: (client: IClient) => void;\r\n\t}) {\r\n\t\tthis.realm = realm;\r\n\t\tthis.config = config;\r\n\t\tthis.onClose = onClose;\r\n\t\tthis.checkInterval = checkInterval;\r\n\t}\r\n\r\n\tpublic start(): void {\r\n\t\tif (this.timeoutId) {\r\n\t\t\tclearTimeout(this.timeoutId);\r\n\t\t}\r\n\r\n\t\tthis.timeoutId = setTimeout(() => {\r\n\t\t\tthis.checkConnections();\r\n\r\n\t\t\tthis.timeoutId = null;\r\n\r\n\t\t\tthis.start();\r\n\t\t}, this.checkInterval);\r\n\t}\r\n\r\n\tpublic stop(): void {\r\n\t\tif (this.timeoutId) {\r\n\t\t\tclearTimeout(this.timeoutId);\r\n\t\t\tthis.timeoutId = null;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate checkConnections(): void {\r\n\t\tconst clientsIds = this.realm.getClientsIds();\r\n\r\n\t\tconst now = new Date().getTime();\r\n\t\tconst { alive_timeout: aliveTimeout } = this.config;\r\n\r\n\t\tfor (const clientId of clientsIds) {\r\n\t\t\tconst client = this.realm.getClientById(clientId);\r\n\r\n\t\t\tif (!client) continue;\r\n\r\n\t\t\tconst timeSinceLastPing = now - client.getLastPing();\r\n\r\n\t\t\tif (timeSinceLastPing < aliveTimeout) continue;\r\n\r\n\t\t\ttry {\r\n\t\t\t\tclient.getSocket()?.close();\r\n\t\t\t} finally {\r\n\t\t\t\tthis.realm.clearMessageQueue(clientId);\r\n\t\t\t\tthis.realm.removeClientById(clientId);\r\n\r\n\t\t\t\tclient.setSocket(null);\r\n\r\n\t\t\t\tthis.onClose?.(client);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","import { MessageType } from \"../../enums\";\r\nimport type { IConfig } from \"../../config\";\r\nimport type { IMessageHandler } from \"../../messageHandler\";\r\nimport type { IRealm } from \"../../models/realm\";\r\n\r\nexport interface IMessagesExpire {\r\n\tstartMessagesExpiration(): void;\r\n\tstopMessagesExpiration(): void;\r\n}\r\n\r\ntype CustomConfig = Pick<IConfig, \"cleanup_out_msgs\" | \"expire_timeout\">;\r\n\r\nexport class MessagesExpire implements IMessagesExpire {\r\n\tprivate readonly realm: IRealm;\r\n\tprivate readonly config: CustomConfig;\r\n\tprivate readonly messageHandler: IMessageHandler;\r\n\r\n\tprivate timeoutId: NodeJS.Timeout | null = null;\r\n\r\n\tconstructor({\r\n\t\trealm,\r\n\t\tconfig,\r\n\t\tmessageHandler,\r\n\t}: {\r\n\t\trealm: IRealm;\r\n\t\tconfig: CustomConfig;\r\n\t\tmessageHandler: IMessageHandler;\r\n\t}) {\r\n\t\tthis.realm = realm;\r\n\t\tthis.config = config;\r\n\t\tthis.messageHandler = messageHandler;\r\n\t}\r\n\r\n\tpublic startMessagesExpiration(): void {\r\n\t\tif (this.timeoutId) {\r\n\t\t\tclearTimeout(this.timeoutId);\r\n\t\t}\r\n\r\n\t\t// Clean up outstanding messages\r\n\t\tthis.timeoutId = setTimeout(() => {\r\n\t\t\tthis.pruneOutstanding();\r\n\r\n\t\t\tthis.timeoutId = null;\r\n\r\n\t\t\tthis.startMessagesExpiration();\r\n\t\t}, this.config.cleanup_out_msgs);\r\n\t}\r\n\r\n\tpublic stopMessagesExpiration(): void {\r\n\t\tif (this.timeoutId) {\r\n\t\t\tclearTimeout(this.timeoutId);\r\n\t\t\tthis.timeoutId = null;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate pruneOutstanding(): void {\r\n\t\tconst destinationClientsIds = this.realm.getClientsIdsWithQueue();\r\n\r\n\t\tconst now = new Date().getTime();\r\n\t\tconst maxDiff = this.config.expire_timeout;\r\n\r\n\t\tconst seen: Record<string, boolean> = {};\r\n\r\n\t\tfor (const destinationClientId of destinationClientsIds) {\r\n\t\t\tconst messageQueue = this.realm.getMessageQueueById(destinationClientId);\r\n\r\n\t\t\tif (!messageQueue) continue;\r\n\r\n\t\t\tconst lastReadDiff = now - messageQueue.getLastReadAt();\r\n\r\n\t\t\tif (lastReadDiff < maxDiff) continue;\r\n\r\n\t\t\tconst messages = messageQueue.getMessages();\r\n\r\n\t\t\tfor (const message of messages) {\r\n\t\t\t\tconst seenKey = `${message.src}_${message.dst}`;\r\n\r\n\t\t\t\tif (!seen[seenKey]) {\r\n\t\t\t\t\tthis.messageHandler.handle(undefined, {\r\n\t\t\t\t\t\ttype: MessageType.EXPIRE,\r\n\t\t\t\t\t\tsrc: message.dst,\r\n\t\t\t\t\t\tdst: message.src,\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tseen[seenKey] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.realm.clearMessageQueue(destinationClientId);\r\n\t\t}\r\n\t}\r\n}\r\n","export enum Errors {\r\n\tINVALID_KEY = \"Invalid key provided\",\r\n\tINVALID_TOKEN = \"Invalid token provided\",\r\n\tINVALID_WS_PARAMETERS = \"No id, token, or key supplied to websocket server\",\r\n\tCONNECTION_LIMIT_EXCEED = \"Server has reached its concurrent user limit\",\r\n}\r\n\r\nexport enum MessageType {\r\n\tOPEN = \"OPEN\",\r\n\tLEAVE = \"LEAVE\",\r\n\tCANDIDATE = \"CANDIDATE\",\r\n\tOFFER = \"OFFER\",\r\n\tANSWER = \"ANSWER\",\r\n\tEXPIRE = \"EXPIRE\",\r\n\tHEARTBEAT = \"HEARTBEAT\",\r\n\tID_TAKEN = \"ID-TAKEN\",\r\n\tERROR = \"ERROR\",\r\n}\r\n","import { EventEmitter } from \"node:events\";\r\nimport type { IncomingMessage } from \"node:http\";\r\nimport url from \"node:url\";\r\nimport type WebSocket from \"ws\";\r\nimport { Errors, MessageType } from \"../../enums\";\r\nimport type { IClient } from \"../../models/client\";\r\nimport { Client } from \"../../models/client\";\r\nimport type { IConfig } from \"../../config\";\r\nimport type { IRealm } from \"../../models/realm\";\r\nimport { WebSocketServer as Server } from \"ws\";\r\nimport type { Server as HttpServer } from \"node:http\";\r\nimport type { Server as HttpsServer } from \"node:https\";\r\n\r\nexport interface IWebSocketServer extends EventEmitter {\r\n\treadonly path: string;\r\n}\r\n\r\ninterface IAuthParams {\r\n\tid?: string;\r\n\ttoken?: string;\r\n\tkey?: string;\r\n}\r\n\r\ntype CustomConfig = Pick<\r\n\tIConfig,\r\n\t\"path\" | \"key\" | \"concurrent_limit\" | \"createWebSocketServer\"\r\n>;\r\n\r\nconst WS_PATH = \"peerjs\";\r\n\r\nexport class WebSocketServer extends EventEmitter implements IWebSocketServer {\r\n\tpublic readonly path: string;\r\n\tprivate readonly realm: IRealm;\r\n\tprivate readonly config: CustomConfig;\r\n\tpublic readonly socketServer: Server;\r\n\r\n\tconstructor({\r\n\t\tserver,\r\n\t\trealm,\r\n\t\tconfig,\r\n\t}: {\r\n\t\tserver: HttpServer | HttpsServer;\r\n\t\trealm: IRealm;\r\n\t\tconfig: CustomConfig;\r\n\t}) {\r\n\t\tsuper();\r\n\r\n\t\tthis.setMaxListeners(0);\r\n\r\n\t\tthis.realm = realm;\r\n\t\tthis.config = config;\r\n\r\n\t\tconst path = this.config.path;\r\n\t\tthis.path = `${path}${path.endsWith(\"/\") ? \"\" : \"/\"}${WS_PATH}`;\r\n\r\n\t\tconst options: WebSocket.ServerOptions = {\r\n\t\t\tpath: this.path,\r\n\t\t\tserver,\r\n\t\t};\r\n\r\n\t\tthis.socketServer = config.createWebSocketServer\r\n\t\t\t? config.createWebSocketServer(options)\r\n\t\t\t: new Server(options);\r\n\r\n\t\tthis.socketServer.on(\"connection\", (socket, req) =>\r\n\t\t\tthis._onSocketConnection(socket, req),\r\n\t\t);\r\n\t\tthis.socketServer.on(\"error\", (error: Error) => this._onSocketError(error));\r\n\t}\r\n\r\n\tprivate _onSocketConnection(socket: WebSocket, req: IncomingMessage): void {\r\n\t\t// An unhandled socket error might crash the server. Handle it first.\r\n\t\tsocket.on(\"error\", (error) => this._onSocketError(error));\r\n\r\n\t\tconst { query = {} } = url.parse(req.url ?? \"\", true);\r\n\r\n\t\tconst { id, token, key }: IAuthParams = query;\r\n\r\n\t\tif (!id || !token || !key) {\r\n\t\t\treturn this._sendErrorAndClose(socket, Errors.INVALID_WS_PARAMETERS);\r\n\t\t}\r\n\r\n\t\tif (key !== this.config.key) {\r\n\t\t\treturn this._sendErrorAndClose(socket, Errors.INVALID_KEY);\r\n\t\t}\r\n\r\n\t\tconst client = this.realm.getClientById(id);\r\n\r\n\t\tif (client) {\r\n\t\t\tif (token !== client.getToken()) {\r\n\t\t\t\t// ID-taken, invalid token\r\n\t\t\t\tsocket.send(\r\n\t\t\t\t\tJSON.stringify({\r\n\t\t\t\t\t\ttype: MessageType.ID_TAKEN,\r\n\t\t\t\t\t\tpayload: { msg: \"ID is taken\" },\r\n\t\t\t\t\t}),\r\n\t\t\t\t);\r\n\r\n\t\t\t\treturn socket.close();\r\n\t\t\t}\r\n\r\n\t\t\treturn this._configureWS(socket, client);\r\n\t\t}\r\n\r\n\t\tthis._registerClient({ socket, id, token });\r\n\t}\r\n\r\n\tprivate _onSocketError(error: Error): void {\r\n\t\t// handle error\r\n\t\tthis.emit(\"error\", error);\r\n\t}\r\n\r\n\tprivate _registerClient({\r\n\t\tsocket,\r\n\t\tid,\r\n\t\ttoken,\r\n\t}: {\r\n\t\tsocket: WebSocket;\r\n\t\tid: string;\r\n\t\ttoken: string;\r\n\t}): void {\r\n\t\t// Check concurrent limit\r\n\t\tconst clientsCount = this.realm.getClientsIds().length;\r\n\r\n\t\tif (clientsCount >= this.config.concurrent_limit) {\r\n\t\t\treturn this._sendErrorAndClose(socket, Errors.CONNECTION_LIMIT_EXCEED);\r\n\t\t}\r\n\r\n\t\tconst newClient: IClient = new Client({ id, token });\r\n\t\tthis.realm.setClient(newClient, id);\r\n\t\tsocket.send(JSON.stringify({ type: MessageType.OPEN }));\r\n\r\n\t\tthis._configureWS(socket, newClient);\r\n\t}\r\n\r\n\tprivate _configureWS(socket: WebSocket, client: IClient): void {\r\n\t\tclient.setSocket(socket);\r\n\r\n\t\t// Cleanup after a socket closes.\r\n\t\tsocket.on(\"close\", () => {\r\n\t\t\tif (client.getSocket() === socket) {\r\n\t\t\t\tthis.realm.removeClientById(client.getId());\r\n\t\t\t\tthis.emit(\"close\", client);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Handle messages from peers.\r\n\t\tsocket.on(\"message\", (data) => {\r\n\t\t\ttry {\r\n\t\t\t\tconst message = JSON.parse(data.toString());\r\n\r\n\t\t\t\tmessage.src = client.getId();\r\n\r\n\t\t\t\tthis.emit(\"message\", client, message);\r\n\t\t\t} catch (e) {\r\n\t\t\t\tthis.emit(\"error\", e);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.emit(\"connection\", client);\r\n\t}\r\n\r\n\tprivate _sendErrorAndClose(socket: WebSocket, msg: Errors): void {\r\n\t\tsocket.send(\r\n\t\t\tJSON.stringify({\r\n\t\t\t\ttype: MessageType.ERROR,\r\n\t\t\t\tpayload: { msg },\r\n\t\t\t}),\r\n\t\t);\r\n\r\n\t\tsocket.close();\r\n\t}\r\n}\r\n","import type WebSocket from \"ws\";\r\n\r\nexport interface IClient {\r\n\tgetId(): string;\r\n\r\n\tgetToken(): string;\r\n\r\n\tgetSocket(): WebSocket | null;\r\n\r\n\tsetSocket(socket: WebSocket | null): void;\r\n\r\n\tgetLastPing(): number;\r\n\r\n\tsetLastPing(lastPing: number): void;\r\n\r\n\tsend<T>(data: T): void;\r\n}\r\n\r\nexport class Client implements IClient {\r\n\tprivate readonly id: string;\r\n\tprivate readonly token: string;\r\n\tprivate socket: WebSocket | null = null;\r\n\tprivate lastPing: number = new Date().getTime();\r\n\r\n\tconstructor({ id, token }: { id: string; token: string }) {\r\n\t\tthis.id = id;\r\n\t\tthis.token = token;\r\n\t}\r\n\r\n\tpublic getId(): string {\r\n\t\treturn this.id;\r\n\t}\r\n\r\n\tpublic getToken(): string {\r\n\t\treturn this.token;\r\n\t}\r\n\r\n\tpublic getSocket(): WebSocket | null {\r\n\t\treturn this.socket;\r\n\t}\r\n\r\n\tpublic setSocket(socket: WebSocket | null): void {\r\n\t\tthis.socket = socket;\r\n\t}\r\n\r\n\tpublic getLastPing(): number {\r\n\t\treturn this.lastPing;\r\n\t}\r\n\r\n\tpublic setLastPing(lastPing: number): void {\r\n\t\tthis.lastPing = lastPing;\r\n\t}\r\n\r\n\tpublic send<T>(data: T): void {\r\n\t\tthis.socket?.send(JSON.stringify(data));\r\n\t}\r\n}\r\n","import { MessageType } from \"../enums\";\r\nimport { HeartbeatHandler, TransmissionHandler } from \"./handlers\";\r\nimport type { IHandlersRegistry } from \"./handlersRegistry\";\r\nimport { HandlersRegistry } from \"./handlersRegistry\";\r\nimport type { IClient } from \"../models/client\";\r\nimport type { IMessage } from \"../models/message\";\r\nimport type { IRealm } from \"../models/realm\";\r\nimport type { Handler } from \"./handler\";\r\n\r\nexport interface IMessageHandler {\r\n\thandle(client: IClient | undefined, message: IMessage): boolean;\r\n}\r\n\r\nexport class MessageHandler implements IMessageHandler {\r\n\tconstructor(\r\n\t\trealm: IRealm,\r\n\t\tprivate readonly handlersRegistry: IHandlersRegistry = new HandlersRegistry(),\r\n\t) {\r\n\t\tconst transmissionHandler: Handler = TransmissionHandler({ realm });\r\n\t\tconst heartbeatHandler: Handler = HeartbeatHandler;\r\n\r\n\t\tconst handleTransmission: Handler = (\r\n\t\t\tclient: IClient | undefined,\r\n\t\t\t{ type, src, dst, payload }: IMessage,\r\n\t\t): boolean => {\r\n\t\t\treturn transmissionHandler(client, {\r\n\t\t\t\ttype,\r\n\t\t\t\tsrc,\r\n\t\t\t\tdst,\r\n\t\t\t\tpayload,\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\tconst handleHeartbeat = (client: IClient | undefined, message: IMessage) =>\r\n\t\t\theartbeatHandler(client, message);\r\n\r\n\t\tthis.handlersRegistry.registerHandler(\r\n\t\t\tMessageType.HEARTBEAT,\r\n\t\t\thandleHeartbeat,\r\n\t\t);\r\n\t\tthis.handlersRegistry.registerHandler(\r\n\t\t\tMessageType.OFFER,\r\n\t\t\thandleTransmission,\r\n\t\t);\r\n\t\tthis.handlersRegistry.registerHandler(\r\n\t\t\tMessageType.ANSWER,\r\n\t\t\thandleTransmission,\r\n\t\t);\r\n\t\tthis.handlersRegistry.registerHandler(\r\n\t\t\tMessageType.CANDIDATE,\r\n\t\t\thandleTransmission,\r\n\t\t);\r\n\t\tthis.handlersRegistry.registerHandler(\r\n\t\t\tMessageType.LEAVE,\r\n\t\t\thandleTransmission,\r\n\t\t);\r\n\t\tthis.handlersRegistry.registerHandler(\r\n\t\t\tMessageType.EXPIRE,\r\n\t\t\thandleTransmission,\r\n\t\t);\r\n\t}\r\n\r\n\tpublic handle(client: IClient | undefined, message: IMessage): boolean {\r\n\t\treturn this.handlersRegistry.handle(client, message);\r\n\t}\r\n}\r\n","export { HeartbeatHandler } from \"./heartbeat\";\r\nexport { TransmissionHandler } from \"./transmission\";\r\n","import type { IClient } from \"../../../models/client\";\r\n\r\nexport const HeartbeatHandler = (client: IClient | undefined): boolean => {\r\n\tif (client) {\r\n\t\tconst nowTime = new Date().getTime();\r\n\t\tclient.setLastPing(nowTime);\r\n\t}\r\n\r\n\treturn true;\r\n};\r\n","import { MessageType } from \"../../../enums\";\r\nimport type { IClient } from \"../../../models/client\";\r\nimport type { IMessage } from \"../../../models/message\";\r\nimport type { IRealm } from \"../../../models/realm\";\r\n\r\nexport const TransmissionHandler = ({\r\n\trealm,\r\n}: {\r\n\trealm: IRealm;\r\n}): ((client: IClient | undefined, message: IMessage) => boolean) => {\r\n\tconst handle = (client: IClient | undefined, message: IMessage) => {\r\n\t\tconst type = message.type;\r\n\t\tconst srcId = message.src;\r\n\t\tconst dstId = message.dst;\r\n\r\n\t\tconst destinationClient = realm.getClientById(dstId);\r\n\r\n\t\t// User is connected!\r\n\t\tif (destinationClient) {\r\n\t\t\tconst socket = destinationClient.getSocket();\r\n\t\t\ttry {\r\n\t\t\t\tif (socket) {\r\n\t\t\t\t\tconst data = JSON.stringify(message);\r\n\r\n\t\t\t\t\tsocket.send(data);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Neither socket no res available. Peer dead?\r\n\t\t\t\t\tthrow new Error(\"Peer dead\");\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// This happens when a peer disconnects without closing connections and\r\n\t\t\t\t// the associated WebSocket has not closed.\r\n\t\t\t\t// Tell other side to stop trying.\r\n\t\t\t\tif (socket) {\r\n\t\t\t\t\tsocket.close();\r\n\t\t\t\t} else {\r\n\t\t\t\t\trealm.removeClientById(destinationClient.getId());\r\n\t\t\t\t}\r\n\r\n\t\t\t\thandle(client, {\r\n\t\t\t\t\ttype: MessageType.LEAVE,\r\n\t\t\t\t\tsrc: dstId,\r\n\t\t\t\t\tdst: srcId,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Wait for this client to connect/reconnect (XHR) for important\r\n\t\t\t// messages.\r\n\t\t\tconst ignoredTypes = [MessageType.LEAVE, MessageType.EXPIRE];\r\n\r\n\t\t\tif (!ignoredTypes.includes(type) && dstId) {\r\n\t\t\t\trealm.addMessageToQueue(dstId, message);\r\n\t\t\t} else if (type === MessageType.LEAVE && !dstId) {\r\n\t\t\t\trealm.removeClientById(srcId);\r\n\t\t\t} else {\r\n\t\t\t\t// Unavailable destination specified with message LEAVE or EXPIRE\r\n\t\t\t\t// Ignore\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\treturn handle;\r\n};\r\n","import type { MessageType } from \"../enums\";\r\nimport type { IClient } from \"../models/client\";\r\nimport type { IMessage } from \"../models/message\";\r\nimport type { Handler } from \"./handler\";\r\n\r\nexport interface IHandlersRegistry {\r\n\tregisterHandler(messageType: MessageType, handler: Handler): void;\r\n\thandle(client: IClient | undefined, message: IMessage): boolean;\r\n}\r\n\r\nexport class HandlersRegistry implements IHandlersRegistry {\r\n\tprivate readonly handlers: Map<MessageType, Handler> = new Map();\r\n\r\n\tpublic registerHandler(messageType: MessageType, handler: Handler): void {\r\n\t\tif (this.handlers.has(messageType)) return;\r\n\r\n\t\tthis.handlers.set(messageType, handler);\r\n\t}\r\n\r\n\tpublic handle(client: IClient | undefined, message: IMessage): boolean {\r\n\t\tconst { type } = message;\r\n\r\n\t\tconst handler = this.handlers.get(type);\r\n\r\n\t\tif (!handler) return false;\r\n\r\n\t\treturn handler(client, message);\r\n\t}\r\n}\r\n","import cors, { CorsOptions } from \"cors\";\r\nimport express from \"express\";\r\nimport publicContent from \"../../app.json\";\r\nimport PublicApi from \"./v1/public\";\r\nimport type { IConfig } from \"../config\";\r\nimport type { IRealm } from \"../models/realm\";\r\n\r\nexport const Api = ({\r\n\tconfig,\r\n\trealm,\r\n\tcorsOptions,\r\n}: {\r\n\tconfig: IConfig;\r\n\trealm: IRealm;\r\n\tcorsOptions: CorsOptions;\r\n}): express.Router => {\r\n\tconst app = express.Router();\r\n\r\n\tapp.use(cors(corsOptions));\r\n\r\n\tapp.get(\"/\", (_, res) => {\r\n\t\tres.send(publicContent);\r\n\t});\r\n\r\n\tapp.use(\"/:key\", PublicApi({ config, realm }));\r\n\r\n\treturn app;\r\n};\r\n","{\r\n\t\"name\": \"PeerJS Server\",\r\n\t\"description\": \"A server side element to broker connections between PeerJS clients.\",\r\n\t\"website\": \"https://peerjs.com/\"\r\n}\r\n","import express from \"express\";\r\nimport type { IConfig } from \"../../../config\";\r\nimport type { IRealm } from \"../../../models/realm\";\r\n\r\nexport default ({\r\n\tconfig,\r\n\trealm,\r\n}: {\r\n\tconfig: IConfig;\r\n\trealm: IRealm;\r\n}): express.Router => {\r\n\tconst app = express.Router();\r\n\r\n\t// Retrieve guaranteed random ID.\r\n\tapp.get(\"/id\", (_, res: express.Response) => {\r\n\t\tres.contentType(\"html\");\r\n\t\tres.send(realm.generateClientId(config.generateClientId));\r\n\t});\r\n\r\n\t// Get a list of all peers for a key, enabled by the `allowDiscovery` flag.\r\n\tapp.get(\"/peers\", (_, res: express.Response) => {\r\n\t\tif (config.allow_discovery) {\r\n\t\t\tconst clientsIds = realm.getClientsIds();\r\n\r\n\t\t\treturn res.send(clientsIds);\r\n\t\t}\r\n\r\n\t\treturn res.sendStatus(401);\r\n\t});\r\n\r\n\treturn app;\r\n};\r\n"],"names":[],"version":3,"file":"index.cjs.map","sourceRoot":"../"}